using ChannelMetaType = paddle::framework::LoDTensor;
using ChannelElement = std::vector<ChannelMetaType>;


class Channel {
 public:
  explicit Channel(std::size_t capacity, std::size_t bytes_limit)
      : capacity_(capacity), bytes_limit_(bytes_limit), current_bytes_(0) {}

  void Put(ChannelElement* buffer_element) {
    std::unique_lock<std::mutex> lock(mu_);

    std::size_t element_bytes = GetElementBytes(*buffer_element);

    PADDLE_ENFORCE(bytes_limit_ > 0 && element_bytes > bytes_limit_,
                   "*Attempted to insert tensors with combined size of %d "
                   "bytes into Staging Area with a memory limit of %d.",
                   element_bytes, bytes_limit_);

    if (IsBounded()) {
      full_cond_var_.wait(lock, [element_bytes, this]() {
        bool bytes_limit_valid =
            bytes_limit_ > 0 ? !WouldExceedMemoryLimit(element_bytes) : true;
        bool capacity_valid = capacity_ > 0 ? !IsCapacityFull() : true;

        return capacity_valid && bytes_limit_valid;
      });
    }

    current_bytes_ += element_bytes;
    buf_.push_back(std::move(*buffer_element));

    lock.unlock();
    empty_cond_var_.notify_all();
  }

  void Get(ChannelElement* buffer_element) {
    std::unique_lock<std::mutex> lock(mu_);

    empty_cond_var_.wait(lock, [this]() { return !buf_.empty(); });

    *buffer_element = std::move(buf_.front());
    buf_.pop_front();

    current_bytes_ -= GetElementBytes(*buffer_element);

    NotifyInserters(&lock);
  }

  size_t Size() {
    std::unique_lock<std::mutex> lock(mu_);
    return buf_.size();
  }

  void Clear() {
    std::unique_lock<std::mutex> lock(mu_);
    buf_.clear();
    current_bytes_ = 0;

    NotifyInserters(&lock);
  }

 private:
  void NotifyInserters(std::unique_lock<std::mutex>* lock) {
    if (IsBounded()) {
      lock->unlock();
      full_cond_var_.notify_all();
    }
  }

  bool IsBounded() const { return capacity_ > 0 || bytes_limit_ > 0; }

  bool IsCapacityFull() const { return buf_.size() >= capacity_; }

  bool WouldExceedMemoryLimit(std::size_t bytes) const {
    return bytes + current_bytes_ > bytes_limit_;
  }

  std::size_t GetElementBytes(const ChannelElement& tuple) {
    return std::accumulate(tuple.begin(), tuple.end(), 0,
                           [](const std::size_t& lhs, const ChannelMetaType& rhs) {
                             return lhs + rhs.memory_size();
                           });
  }

 private:
  std::size_t capacity_;
  std::size_t bytes_limit_;
  std::size_t current_bytes_;
  std::mutex mu_;
  std::condition_variable empty_cond_var_;
  std::condition_variable full_cond_var_;
  std::deque<ChannelElement> buf_;
};